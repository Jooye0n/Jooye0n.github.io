---
title: 운영체제(Operating System, OS) 이론정리
author: Jooye0n
date: 2024-07-14 16:10:00 +09:00
categories: [Github, OS]
tags: [Github, OS]
toc: true
toc_sticky: true
toc_label: 목차
math: true
mermaid: true
---
## Chapter 1. Introduction to Operating Systems 
---
### 1.1 운영체제의 의미
사용자 및 다른 모든 소프트웨어와 하드웨어를 연결해주는 소프트웨어 계층을 말한다.  
운영체제는 하드웨어 바로 위에 설치되어있다. 

### 1.2 운영체제의 범위
좁은 의미의 운영체제는 커널을 말한다. 운영체제의 핵심적인 부분으로 전원을 킨 이후부터 부팅이 일어난 후 항상 메모리에 상주하는 부분을 일컫는다.   
넓은 의미의 운영체제는 커널을 포함한 각종 주변 시스템 유틸리티를 포함한 개념을 뜻한다.
(ex: 윈도우를 설치할때 추가되는 각종 파일)

### 1.3 운영체제의 목적
운영체제의 목적에는 처리능력 향상, 반환 시간 단축, 사용 가능도 향상, 신뢰도 향상 등이 있다.  처리능력, 반환시간, 사용가능도, 신뢰도는 운영체제의 성능을 평가하는 기준이 된다.

> 처리능력(Throughput) : 일정 시간 내에 시스템이 처리하는 일의 양  
> 반환시간(Turn Around Time) : 시스템에 작업을 의뢰한 시간부터 처리가 완료될 때까지 걸린 시간  
> 사용가능도(Availability) : 시스템을 사용할 필요가 있을 때 즉시 사용 가능한 정도  
> 신뢰도(Reliabilty) : 시스템이 주어진 문제를 정확하게 해결하는 정도

### 1.4 운영체제의 기능
- 컴퓨터 시스템의 하드웨어와 소프트웨어 자원을 관리한다.
> 하드웨어 자원 : 프로세서, 기억장치, 입출력장치 등  
> 소프트웨어 자원 : 프로세스, 파일, 메시지 등  
- 자원의 효율적 관리를 위한 스케줄링 기능을 제공한다.  
- 사용자와 시스템간의 편리한 인터페이스를 제공한다.  
- 데이터를 관리하며 자원의 공유 기능을 제공한다.  
- 시스템의 오류를 검사하고 복구한다.
- 자원 보호 기능을 제공한다.
- 입출력에 대한 보조 기능을 제공한다.
- 가상 계산기 능력을 제공한다.

### 1.5 운영체제의 분류
1) 동시작업 가능여부에 따른 분류  
- 싱글 프로세스
: 한 번에 하나의 작업만 처리   
- 멀티 프로세스
:­ 동시에 두 개 이상의 작업 처리  

2) 사용자 수에 따른 분류 (하나의 계정에 여러 사용자가 동시 접근할 수 있는지)  
- 단일 사용자 
: MS-DOS, MS Windows 등
- 다중 사용자
: UNIX, NT server 등

3) 처리방식에 따른 분류  
- 일괄 처리(batch processing)
: 작업 요청의 일정 양을 모아서 한 번에 처리하는 시스템. 작업이 완전 종료될 때까지 기다려야 한다.   
- 시분할(time sharing)  
: 여러 작업을 수행할 때 컴퓨터 처리 능력을 일정한 시간 단위로 분할하여 사용. 일괄 처리 방식보다 짧은 응답 시간을 가진다. (사람이 느끼기에 CPU 로부터 interactive 한 서비스를 받는다. 현재 우리의 컴퓨터)    
- 실시간(realtime OS)  
: 데드라인이 존재하여 정해진 시간 안에 어떠한 일이 반드시 종료됨을 보장하여야 하는 시스템을 위한 OS.  special purpose system 을 위함. 실시간 컴퓨팅(real-time computing, RTC)을 활용한 시스템.  
> Hard realtime system : 원자로, 공장제어, 미사일 제어, 반도체 장비, 로보트 제어   
> Soft realtime system : 영상 스트리밍, 네비게이션, 블랙박스

### 1.6 관련 용어
- multi tasking : 여러 작업을 조금씩 번갈아가며 처리하는 상태. CPU는 매순간 하나의 작업만 실행 중이다.  
- multi programming : 메모리에 여러 프로그램이 동시에 올라가는 것. 메모리를 강조한 측면의 multi tasking. (multi tasking은 multi programming이 지원 되어야 가능하다.)   
- time sharing : CPU를 강조한 측면의 multi tasking. (multi tasking은 time-sharing이 지원 되어야 가능하다.)  
- multi process : 실행 중인 프로그램   
- multi processor : processor는 보통 CPU를 말하며, multi processor는 CPU가 여러 개 있는 컴퓨터를 말한다. 다른 용어들과 HW적으로 다른 환경이다.  

## Chapter 2. System Structure & Program Execution
---
### 2.1 컴퓨터 시스템의 구조
![](/assets/img/2024-07-14-OS/structor.png)  
컴퓨터 시스템은 크게 CPU, 메모리, IO device 로 구성되어 있다.
CPU는 매 클럭 사이클마다 메모리에서 instruction 즉, 하나의 기계어를 읽고 수행한다. PC(Program counter)가 가리키는 주소에 접근하여 일을 수행한다.  
timer는 특정 프로그램이 CPU를 독점하는 것을 막기 위해 존재하는 HW다. timer 값이 0이 되면 timer interrupt가 발생하여 실행 중이었던 프로세스로부터 CPU를 빼앗는다. interrupt가 들어오면 CPU 제어권이 OS에게 넘어가게 된다.  
mode bit는 CPU 제어를 OS가 가지고 있는지 또는 사용자가 가지고 있는지를 나타낸다. 1은 사용자모드, 0은 OS모드를 뜻한다.  
Disk는 보조 장치로 이야기 하지만 IO device로의 역할도 한다. 메인 메모리에서 데이터를 읽기도 메모리에 데이터를 저장하기도 하기 때문이다.   
device driver는 각 device를 처리하기 위해 즉, device의 인터페이스에 맞게 접근할 수 있도록 설치하는 소프트웨어 모듈을 뜻한다. CPU 가 실행하는 장치를 수행하기 위해서 필요한 코드를 담고 있다. 하나의 하드웨어당 장치에 접근하기 위한 하나의 device 모듈을 설치해야 한다.  
device controller는 각 device마다 붙어있는 작은 HW 장치이다. 전담 CPU 역할을 한다.  
instruction 수행 중 IO 장치를 접근해야 하는 상황이 오면 device driver는 disk controller는에게 지시를 내리고, 최종적으로 device disk 안 펌웨어에서 읽어온 명령어를 수행한다.  

> OS에게 제어권이 넘어갈 때는 `interrupt`가 유일하다. PC가 가리키는 사용자 프로그램의 매 instruction 요청을 수행하던 중 interrupt가 발생하면 OS에게 제어권이 넘어간다.  
interrupt 발생 시점의 register와 program counter를 save한 후 CPU의 제어를 interrupt 처리 루틴에 넘긴다.  
`interrupt` 라고 하면 보통 HW interrupt를 뜻하며 IO controller 의 interrupt, timer interrupt를 포함하지만, 넓은 의미의 interrupt에선 trap도 포함한다.  
interrupt나 exception 발생시 HW가 mode bit를 0으로 바꾸고, 사용자 프로그램에게 CPU를 넘기기 전에 1로 바꿔준다.  
{: .prompt-info }
> trap : SW interrupt 를 뜻하며 exception(프로그램이 오류를 범한 경우), System call(사용자 프로그램이 커널 함수를 호출하는 경우)를 포함한다.  
> interrupt routine : 각 interrupt 마다의 수행업무가 정의된 함수.  
> interrupt vector : interrupt routine의 주소가 정리된 table.  

### 2.2 IO의 수행
IO device를 접근하는 모든 실행은 modbit가 0일 때만 가능하다. 즉 OS만 실행할 수 있다. 사용자 프로그램은 CPU instruction 실행 중 임의로 IO device를 실행할 수 없다. 이땐 OS에게 요청해야 하는데, 요청을 위해선 PC가 OS의 주소 영역으로 점프해야 하고 이는 modbit이 0일 때는 불가능하므로 `System call` 을 한다. System call이란 OS에 있는 함수를 사용자 프로그램이 요청하는 것이다. System call이 발생하면 의도적으로 interrupt 라인을 세팅한 후 CPU 가 하던 일을 멈추며 제어권이 OS에게 넘어가게 된다.  

### 2.3 IO에서의 동기식(synchronous IO)과 비동기식(asynchronous IO)
![](/assets/img/2024-07-14-OS/sync.png)  
두 경우 모두 IO의 완료는 interrupt로 알려준다.
- 동기식 입출력(synchronous IO)
: IO 요청 후 입출력 작업이 완료된 후에야 제어가 사용자 프로그램에 넘어간다. 결과를 보고 다음작업을 결정해야 할 때 어울린다. 
  - 구현 방법 1
    - IO가 완료될 때까지 CPU를 낭비시킴. 
    - 매 시점 하나의 IO만 일어날 수 있음.
  - 구현 방법 2
    - IO가 완료될 때까지 해당 프로그램에게서 CPU를 빼앗음.
    - IO 처리를 기다리는 줄에 그 프로그램을 줄 세움.
    - 다른 프로그램에게 CPU를 줌.  
- 비동기식 입출력(asynchronous IO)
: IO가 시작된 후 입출력 작업이 끝나기를 기다리지 않고 제어가 사용자 프로그램에 즉시 넘어간다. 읽어온 데이터와 상관없이 할 수 있는 작업에 어울린다.  

### 2.4 DMA(direct memory access)
: 메모리 버퍼, 포인터, 카운터를 사용하여 device controller가 CPU이 도움없이 DMA controller를 이용하여 데이터를 직접 메모리로 전송하는 입출력 방식이다. 빠른 IO device를 메모리에 가까운 속도로 처리하기 위해 사용한다. 바이트 단위가 아니라 블록 단위로 인터럽트를 발생시킨다. 원래 메모리에 접근할 수 있는 장치는 CPU 뿐이지만 CPU는 interrupt를 많이 당해서 overhead 발생이 쉽기 때문에, DMA도 메모리에 접근할 수 있도록 하여 작은 일들은(버퍼가 차기 전까지의 일들)은 DMA 가 처리한 후 device buffer storage 가 찰때 DMA 가 CPU 에게 말해주는 방식으로 진행한다.  

### 2.5 저장장치 계층구조
![](/assets/img/2024-07-14-OS/hierarchy_str.png)  
- 최상단엔 CPU / register 가 존재한다.
- 상단으로 올라갈수록, 빈도 높다. 속도 빠르다. 가격 비싸다. 용량 작다.
- 메인 메모리까지 휘발성이고, 아래부턴 비휘발성이다. 
- CPU는 메인 메모리까지 접근이 가능하다. (excutable 하다)
- Caching은 재사용을 목적으로 더 빠른 저장 시스템에 정보 저장하는 것을 말한다.

### 2.6 프로그램의 실행
![](/assets/img/2024-07-14-OS/file_sys.png)  
프로그램은 실행파일 형태로 파일 시스템(하드디스크)에 저장되며, 실행파일을 실행시키게 되면 메모리에
올라가서 프로세스가 된다. 어떤 프로그램을 실행시키게 되면, 가상 메모리에 프로그램의 메모리 주소 공간이 형성된다. 이 공간은 스택, 데이터, 코드를 담고있다. 코드는 CPU 에서 실행할 기계어 코드를 데이터는 전역변수, 자료구조를 스택은 함수 형태를 저장한다. 실행될 부분만 물리 메모리에 load 하여 사용한다. Swap area는 메모리의 연장선이므로 휘발성이다.  

### 2.7 OS 커널 주소 공간의 내용
![](/assets/img/2024-07-14-OS/kernel.png)  
- Code : 각 interrupt마다 할 일이 함수로 정의되어있다.
- Data : OS가 사용하는 자료구조가 정의되어있다. HW 하나당 하나의 구조가 있으며 이 구조를 PCB (= process control block)라 한다.  
- Stack : 함수의 호출과 return시 사용한다. 사용자 프로그램마다 커널 스택을 따로 사용한다.  

### 2.8 함수의 종류
- 사용자 정의 함수 : 직접 작성한 함수 (내 주소공간의 code 영역에 존재)
- 라이브러리 함수 : 갖다 쓴 함수. 실행 파일에 포함되어 있다.(내 주소공간의 code 영역에 존재)
- 커널 함수: 운영체제 안에서 정의된 함수. System call을 통해 가져다 쓸 수 있다. interrput 라인 세팅 후 CPU 제어를 넘기면서 넘어가야 한다. (운영체제 주소공간의 code 영역에 존재)

## Chapter 3. Process
---


